# Renovating the Labyrinth

A solo submission for the University of Waterloo Game Dev Club's Fall 2024 Game Jam and voted winner of the technical achievement award.
It is a game made using raycasting in vanilla JavaScript on an HTML canvas.

You can also find the game on [itch.io](https://arnavcs.itch.io/renovating-the-labyrinth) or the [webpage](https://arnavcs.github.io/renovating-the-labyrinth/).

## Raycasting

The raycasting method is optimized to ensure that the game can be played in real time.
For this reason, the only objects which are raycasted are square walls.

The rendering method is based off of calculating the height of the wall intersected by a given ray based on the distance to the interseciton ray based on the distance to the intersection.
In order to avoid a fisheye effect, the height is then scaled as well.
See [this](https://lodev.org/cgtutor/raycasting.html) raycasting guide for more information.

## Dithering

The colour of a column of pixels is determined by the wall that the corresponding ray intersects.
The alpha value is determined based on the distance the ray travels and the direction of the colliding face.

The implementation of dithering is based solely off of alpha values of the pixels.
In specific, ordered dithering is used to ensure that as the game updates, the same image is rendered.
For this reason, a 4 by 4 Bayer matrix is used to achieve ordered dithering.

## Collisions

We needed to recognize when a square and the player are colliding, and which faces of a wall the player collides with.
To this end, an approximation of the player as a circle is used, and we check intersection with the faces of neighbouring walls.

If there is an intersection with the face of a wall, then check if the desired movement is into the wall.
If it is, then ensure to take the projection of the movement in the direction parallel to the wall to avoid clipping into the wall.

This method of physics is pre-emptive rather than one which requires to move the player out of the wall on every physics step.

## Maze Generation

The maze is randomly generated by considering the grid of squares as a graph with certain faces (squares which have coordinates which are both odd indicies) and edges (squares which have coordinates which are both even indicies).
Any maze without cycles is then equivalently a spanning tree of our graph.

Thus, we can use a randomized Prim's algorithm to generate a randomized maze.

